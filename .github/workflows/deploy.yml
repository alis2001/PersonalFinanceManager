name: Deploy Finance Tracker

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production

env:
  DOCKER_REGISTRY: alis2001
  PROJECT_NAME: finance-tracker

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            services/*/package-lock.json
            frontend/web/package-lock.json

      - name: Install dependencies and test
        run: |
          echo "Running tests..."
          # Add actual test commands here

  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    strategy:
      matrix:
        service: [gateway, auth, expense, income, category, analytics, analytics-engine, reporting-engine, ml-engine, web]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # FIXED: Always create latest tags for deployment
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/finance-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      # FIXED: Correct build context determination
      - name: Determine build context
        id: context
        run: |
          case "${{ matrix.service }}" in
            "web")
              echo "context=frontend/web" >> $GITHUB_OUTPUT
              echo "dockerfile=frontend/web/Dockerfile" >> $GITHUB_OUTPUT
              ;;
            "analytics")
              echo "context=services/analytics" >> $GITHUB_OUTPUT
              echo "dockerfile=services/analytics/Dockerfile" >> $GITHUB_OUTPUT
              ;;
            "analytics-engine"|"reporting-engine"|"ml-engine")
              echo "context=services/${{ matrix.service }}" >> $GITHUB_OUTPUT
              echo "dockerfile=services/${{ matrix.service }}/Dockerfile" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "context=services/${{ matrix.service }}" >> $GITHUB_OUTPUT
              echo "dockerfile=services/${{ matrix.service }}/Dockerfile" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Build and push (web with build args)
        if: matrix.service == 'web'
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.context.outputs.context }}
          file: ${{ steps.context.outputs.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            REACT_APP_API_URL=http://${{ secrets.EC2_HOST }}:8080/api

      - name: Build and push (other services)
        if: matrix.service != 'web'
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.context.outputs.context }}
          file: ${{ steps.context.outputs.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: Deploy to Environment
    runs-on: ubuntu-latest
    needs: [build]
    if: always() && needs.build.result == 'success'
    environment: ${{ (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production') && 'production' || 'staging' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine deployment environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "env_file=.env.production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "env_file=.env.staging" >> $GITHUB_OUTPUT
          fi

      # FIXED: Comprehensive EC2 environment preparation
      - name: Prepare EC2 environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "🚀 Preparing EC2 environment..."
            
            # Install required packages
            sudo apt-get update
            sudo apt-get install -y curl wget
            
            # Check Docker installation
            if ! command -v docker &> /dev/null; then
                echo "Installing Docker..."
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
                sudo usermod -aG docker ubuntu
            fi
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
                echo "Installing Docker Compose..."
                sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Create directory structure
            sudo mkdir -p /home/ubuntu/finance-tracker/infrastructure/database/init
            sudo chown -R ubuntu:ubuntu /home/ubuntu/finance-tracker
            
            # Navigate to app directory
            cd /home/ubuntu/finance-tracker
            
            # Determine Docker Compose command
            if command -v docker-compose &> /dev/null; then
                DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null; then
                DOCKER_COMPOSE="docker compose"
            else
                echo "ERROR: Docker Compose not found"
                exit 1
            fi
            
            echo "Using Docker Compose command: $DOCKER_COMPOSE"
            
            # Stop any existing containers
            echo "Stopping existing services..."
            $DOCKER_COMPOSE down --remove-orphans 2>/dev/null || true
            
            echo "✅ EC2 environment prepared"

      - name: Create deployment files on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ubuntu/finance-tracker
            
            # Create environment file with all variables
            cat > ${{ steps.env.outputs.env_file }} << 'ENVEOF'
            # Application
            APP_ENV=${{ steps.env.outputs.environment }}
            NODE_ENV=production
            
            # Database Configuration
            DB_HOST=postgres
            DB_PORT=5432
            DB_NAME=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_NAME || secrets.DB_NAME }}
            DB_USER=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_USER || secrets.DB_USER }}
            DB_PASSWORD=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_PASSWORD || secrets.DB_PASSWORD }}
            DB_EXTERNAL_PORT=5433
            
            # PostgreSQL
            POSTGRES_DB=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_NAME || secrets.DB_NAME }}
            POSTGRES_USER=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_USER || secrets.DB_USER }}
            POSTGRES_PASSWORD=${{ steps.env.outputs.environment == 'production' && secrets.PROD_DB_PASSWORD || secrets.DB_PASSWORD }}
            
            # Redis
            REDIS_HOST=redis
            REDIS_PORT=6379
            
            # RabbitMQ
            RABBITMQ_HOST=rabbitmq
            RABBITMQ_PORT=5672
            RABBITMQ_MANAGEMENT_PORT=15672
            RABBITMQ_DEFAULT_USER=${{ steps.env.outputs.environment == 'production' && secrets.PROD_RABBITMQ_USER || secrets.RABBITMQ_USER }}
            RABBITMQ_DEFAULT_PASS=${{ steps.env.outputs.environment == 'production' && secrets.PROD_RABBITMQ_PASS || secrets.RABBITMQ_PASS }}
            
            # JWT Configuration
            JWT_SECRET=${{ steps.env.outputs.environment == 'production' && secrets.PROD_JWT_SECRET || secrets.JWT_SECRET }}
            JWT_EXPIRY=1h
            BCRYPT_ROUNDS=12
            
            # Service URLs (Internal Docker Network)
            AUTH_SERVICE_URL=http://auth:3000
            EXPENSE_SERVICE_URL=http://expense:3000
            INCOME_SERVICE_URL=http://income:3000
            CATEGORY_SERVICE_URL=http://category:3000
            ANALYTICS_SERVICE_URL=http://analytics:8000
            ANALYTICS_ENGINE_URL=http://analytics-engine:8080
            REPORTING_ENGINE_URL=http://reporting-engine:8080
            ML_ENGINE_URL=http://ml-engine:8080
            
            # Service Ports (External Access)
            GATEWAY_PORT=8080
            AUTH_SERVICE_PORT=8001
            EXPENSE_SERVICE_PORT=8002
            INCOME_SERVICE_PORT=8003
            CATEGORY_SERVICE_PORT=8004
            ANALYTICS_SERVICE_PORT=8005
            ANALYTICS_ENGINE_PORT=8006
            REPORTING_ENGINE_PORT=8007
            ML_ENGINE_PORT=8008
            
            # Security & Rate Limiting
            ENABLE_CORS=true
            RATE_LIMIT_WINDOW=900
            RATE_LIMIT_MAX_REQUESTS=100
            SESSION_TIMEOUT=3600
            
            # Logging
            LOG_LEVEL=info
            
            # Email Service Configuration
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_SECURE=false
            SMTP_USERNAME=${{ secrets.SMTP_USERNAME }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            SMTP_FROM_NAME=Finance Tracker
            SMTP_FROM_EMAIL=${{ secrets.SMTP_FROM_EMAIL }}
            
            # Email Settings
            EMAIL_VERIFICATION_EXPIRY_HOURS=24
            LOGIN_VERIFICATION_EXPIRY_MINUTES=10
            PASSWORD_RESET_EXPIRY_HOURS=2
            EMAIL_MAX_RETRIES=3
            EMAIL_RETRY_DELAY=5000
            
            # Application URLs
            PUBLIC_IP=${{ secrets.EC2_HOST }}
            FRONTEND_URL=http://${{ secrets.EC2_HOST }}:3000
            API_URL=http://${{ secrets.EC2_HOST }}:8080
            
            # Company Information
            APP_NAME=Finance Tracker
            COMPANY_NAME=Finance Tracker Inc
            SUPPORT_EMAIL=support@financetracker.com
            BRAND_COLOR=#1a1a1a
            LOGO_URL=
            
            # Analytics Service Configuration
            PYTHON_ENV=${{ steps.env.outputs.environment }}
            ASYNC_POOL_SIZE=20
            REQUEST_TIMEOUT=30
            BATCH_SIZE=1000
            MAX_CONCURRENT_REQUESTS=100
            
            # Analytics Features
            ANALYTICS_DEFAULT_PERIOD=monthly
            ANALYTICS_SUPPORTED_PERIODS=daily,weekly,monthly,quarterly,yearly
            ANALYTICS_MAX_DATA_POINTS=10000
            
            # ML & Forecasting
            ML_MODEL_PATH=/app/models
            ML_RETRAIN_INTERVAL=86400
            ML_MIN_DATA_POINTS=30
            FORECAST_DAYS_DEFAULT=30
            FORECAST_DAYS_MAX=365
            FORECAST_CONFIDENCE_INTERVAL=0.95
            
            # Data Export
            EXPORT_MAX_RECORDS=100000
            EXPORT_FORMATS=csv,xlsx,json,pdf
            EXPORT_CACHE_TTL=1800
            
            # Cache TTL Settings
            CACHE_TTL_DEFAULT=3600
            CACHE_TTL_SHORT=300
            CACHE_TTL_LONG=86400
            
            # Frontend Configuration
            REACT_APP_API_URL=http://${{ secrets.EC2_HOST }}:8080/api
            REACT_APP_ANALYTICS_API_URL=http://${{ secrets.EC2_HOST }}:8080/api/analytics
            
            # CORS Configuration
            ALLOWED_ORIGINS=http://${{ secrets.EC2_HOST }}:3000,http://localhost:3000
            CORS_ORIGIN=http://${{ secrets.EC2_HOST }}:3000
            CORS_ORIGINS=http://${{ secrets.EC2_HOST }}:3000,http://localhost:3000
            ORIGIN=http://${{ secrets.EC2_HOST }}:3000
            
            # Performance & Timeout Settings
            REQUEST_TIMEOUT=75000
            PROXY_TIMEOUT=70000
            SERVICE_REQUEST_TIMEOUT=60000
            DATABASE_TIMEOUT=30000
            
            # Docker Configuration
            DOCKER_RESTART_POLICY=unless-stopped
            ENABLE_HEALTH_CHECKS=true
            HEALTH_CHECK_INTERVAL=30s
            HEALTH_CHECK_TIMEOUT=10s
            HEALTH_CHECK_RETRIES=3
            ENVEOF
            
            # FIXED: Create production docker-compose.yml with proper health checks
            cat > docker-compose.yml << 'DOCKEREOF'
            version: '3.8'

            services:
              # Database Services
              postgres:
                image: postgres:15-alpine
                container_name: finance-postgres
                env_file:
                  - .env
                environment:
                  POSTGRES_DB: ${POSTGRES_DB}
                  POSTGRES_USER: ${POSTGRES_USER}
                  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                  POSTGRES_MAX_CONNECTIONS: 200
                  POSTGRES_SHARED_BUFFERS: 256MB
                ports:
                  - "${DB_EXTERNAL_PORT}:5432"
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                  - ./infrastructure/database/init:/docker-entrypoint-initdb.d
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
                  interval: 15s
                  timeout: 10s
                  retries: 5
                  start_period: 30s

              redis:
                image: redis:7-alpine
                container_name: finance-redis
                env_file:
                  - .env
                ports:
                  - "${REDIS_PORT}:6379"
                volumes:
                  - redis_data:/data
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
                command: >
                  redis-server 
                  --maxmemory 512mb 
                  --maxmemory-policy allkeys-lru 
                  --tcp-keepalive 60
                  --timeout 300

              rabbitmq:
                image: rabbitmq:3-management-alpine
                container_name: finance-rabbitmq
                env_file:
                  - .env
                environment:
                  RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
                  RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
                ports:
                  - "${RABBITMQ_PORT}:5672"
                  - "${RABBITMQ_MANAGEMENT_PORT}:15672"
                volumes:
                  - rabbitmq_data:/var/lib/rabbitmq
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: rabbitmq-diagnostics -q ping
                  interval: 30s
                  timeout: 30s
                  retries: 3

              # API Gateway
              gateway:
                image: alis2001/finance-gateway:latest
                container_name: finance-gateway
                env_file:
                  - .env
                ports:
                  - "${GATEWAY_PORT}:3000"
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                  auth:
                    condition: service_started
                  expense:
                    condition: service_started
                  income:
                    condition: service_started
                environment:
                  - NODE_ENV=${NODE_ENV}
                  - PORT=3000
                  - AUTH_SERVICE_URL=http://auth:3000
                  - EXPENSE_SERVICE_URL=http://expense:3000
                  - INCOME_SERVICE_URL=http://income:3000
                  - CATEGORY_SERVICE_URL=http://category:3000
                  - ANALYTICS_SERVICE_URL=http://analytics:8000
                  - ANALYTICS_ENGINE_URL=http://analytics-engine:8080
                  - REPORTING_ENGINE_URL=http://reporting-engine:8080
                  - ML_ENGINE_URL=http://ml-engine:8080
                  - ENABLE_CORS=${ENABLE_CORS}
                  - PUBLIC_IP=${PUBLIC_IP}
                  - FRONTEND_URL=${FRONTEND_URL}
                  - API_URL=${API_URL}
                  - REQUEST_TIMEOUT=75000
                  - PROXY_TIMEOUT=70000
                networks:
                  - finance-network
                restart: unless-stopped
                # FIXED: Use wget instead of curl for health checks
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 30s

              # Node.js Microservices
              auth:
                image: alis2001/finance-auth:latest
                container_name: finance-auth
                env_file:
                  - .env
                ports:
                  - "${AUTH_SERVICE_PORT}:3000"
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                environment:
                  - NODE_ENV=${APP_ENV}
                  - PORT=3000
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                  - REDIS_HOST=redis
                  - REDIS_PORT=6379
                  - JWT_SECRET=${JWT_SECRET}
                  - SMTP_HOST=${SMTP_HOST}
                  - SMTP_PORT=${SMTP_PORT}
                  - SMTP_USERNAME=${SMTP_USERNAME}
                  - SMTP_PASSWORD=${SMTP_PASSWORD}
                  - REQUEST_TIMEOUT=60000
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              expense:
                image: alis2001/finance-expense:latest
                container_name: finance-expense
                env_file:
                  - .env
                ports:
                  - "${EXPENSE_SERVICE_PORT}:3000"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - NODE_ENV=${APP_ENV}
                  - PORT=3000
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                  - REQUEST_TIMEOUT=60000
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              income:
                image: alis2001/finance-income:latest
                container_name: finance-income
                env_file:
                  - .env
                ports:
                  - "${INCOME_SERVICE_PORT}:3000"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - NODE_ENV=${APP_ENV}
                  - PORT=3000
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                  - REQUEST_TIMEOUT=60000
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              category:
                image: alis2001/finance-category:latest
                container_name: finance-category
                env_file:
                  - .env
                ports:
                  - "${CATEGORY_SERVICE_PORT}:3000"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - NODE_ENV=${APP_ENV}
                  - PORT=3000
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                  - REQUEST_TIMEOUT=60000
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              # Analytics Service (Python FastAPI)
              analytics:
                image: alis2001/finance-analytics:latest
                container_name: finance-analytics-api
                env_file:
                  - .env
                ports:
                  - "${ANALYTICS_SERVICE_PORT}:8000"
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                environment:
                  - PYTHON_ENV=${APP_ENV}
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                  - REDIS_HOST=redis
                  - REDIS_PORT=6379
                  - JWT_SECRET=${JWT_SECRET}
                  - REQUEST_TIMEOUT=60
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8000/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              # C++ Engines
              analytics-engine:
                image: alis2001/finance-analytics-engine:latest
                container_name: finance-analytics-engine
                env_file:
                  - .env
                ports:
                  - "${ANALYTICS_ENGINE_PORT}:8080"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              reporting-engine:
                image: alis2001/finance-reporting-engine:latest
                container_name: finance-reporting-engine
                env_file:
                  - .env
                ports:
                  - "${REPORTING_ENGINE_PORT}:8080"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              ml-engine:
                image: alis2001/finance-ml-engine:latest
                container_name: finance-ml-engine
                env_file:
                  - .env
                ports:
                  - "${ML_ENGINE_PORT}:8080"
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=${DB_NAME}
                  - DB_USER=${DB_USER}
                  - DB_PASSWORD=${DB_PASSWORD}
                networks:
                  - finance-network
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              # Frontend
              web:
                image: alis2001/finance-web:latest
                container_name: finance-web
                env_file:
                  - .env
                ports:
                  - "3000:3000"
                environment:
                  - NODE_ENV=production
                networks:
                  - finance-network
                restart: unless-stopped
                depends_on:
                  - gateway
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000", "||", "exit", "1"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

            volumes:
              postgres_data:
              redis_data:
              rabbitmq_data:

            networks:
              finance-network:
                driver: bridge
            DOCKEREOF
            
            echo "✅ Production deployment files created successfully"

      - name: Copy database init files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "infrastructure/database/init/"
          target: "/home/ubuntu/finance-tracker/infrastructure/database/"
          overwrite: true

      - name: Deploy to ${{ steps.env.outputs.environment }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          command_timeout: 20m
          script: |
            set -e
            cd /home/ubuntu/finance-tracker
            
            echo "🚀 Starting ${{ steps.env.outputs.environment }} deployment..."
            
            # Use the correct environment file
            cp ${{ steps.env.outputs.env_file }} .env || echo "Using existing .env"
            
            # Install required packages if missing
            sudo apt-get update && sudo apt-get install -y wget curl || echo "Packages already installed"
            
            echo "Environment: ${{ steps.env.outputs.environment }}"
            echo "EC2 Host: ${{ secrets.EC2_HOST }}"
            echo "Docker Registry: ${{ env.DOCKER_REGISTRY }}"
            
            # Detect Docker Compose command
            if command -v docker-compose >/dev/null 2>&1; then
                DOCKER_COMPOSE="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE="docker compose"
            else
                echo "❌ Docker Compose not found, installing..."
                sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                sudo chmod +x /usr/local/bin/docker-compose
                DOCKER_COMPOSE="docker-compose"
            fi
            
            echo "✅ Using Docker Compose: $DOCKER_COMPOSE"
            
            # FIXED: Comprehensive container cleanup to prevent name conflicts
            echo "🧹 Comprehensive container cleanup..."
            
            # Stop all containers first
            $DOCKER_COMPOSE down --remove-orphans 2>/dev/null || echo "No compose services to stop"
            
            # Force remove containers by name (handles containers created outside compose)
            echo "  Removing containers by name..."
            CONTAINER_NAMES=(
                "finance-postgres"
                "finance-redis" 
                "finance-rabbitmq"
                "finance-gateway"
                "finance-auth"
                "finance-expense"
                "finance-income"
                "finance-category"
                "finance-analytics"
                "finance-analytics-api"
                "finance-analytics-engine"
                "finance-reporting-engine"
                "finance-ml-engine"
                "finance-web"
                "finance-web-placeholder"
            )
            
            for container in "${CONTAINER_NAMES[@]}"; do
                if docker ps -a --format "{{.Names}}" | grep -q "^${container}$"; then
                    echo "    Removing $container..."
                    docker rm -f "$container" 2>/dev/null || echo "    Failed to remove $container"
                fi
            done
            
            # Remove any remaining containers with "finance" in the name
            echo "  Removing any remaining finance containers..."
            docker ps -a --format "{{.Names}}" | grep finance | while read container; do
                echo "    Removing orphaned container: $container"
                docker rm -f "$container" 2>/dev/null || echo "    Failed to remove $container"
            done
            
            # Clean up networks
            echo "  Cleaning up networks..."
            docker network ls --format "{{.Name}}" | grep finance | while read network; do
                echo "    Removing network: $network"
                docker network rm "$network" 2>/dev/null || echo "    Failed to remove $network"
            done
            
            # Verify cleanup
            REMAINING=$(docker ps -a --format "{{.Names}}" | grep finance | wc -l || echo "0")
            echo "  ✅ Cleanup complete. Remaining finance containers: $REMAINING"
            
            # Pull images with fallback to existing images
            echo "📦 Pulling Docker images..."
            
            # Infrastructure images (always work)
            docker pull postgres:15-alpine || echo "Using cached postgres"
            docker pull redis:7-alpine || echo "Using cached redis"  
            docker pull rabbitmq:3-management-alpine || echo "Using cached rabbitmq"
            
            # Application images (with graceful fallback)
            SERVICES=("gateway" "auth" "expense" "income" "category" "analytics" "analytics-engine" "reporting-engine" "ml-engine" "web")
            
            for service in "${SERVICES[@]}"; do
                echo "  Pulling ${{ env.DOCKER_REGISTRY }}/finance-${service}:latest"
                if docker pull "${{ env.DOCKER_REGISTRY }}/finance-${service}:latest"; then
                    echo "    ✅ Successfully pulled ${service}"
                else
                    echo "    ⚠️ Failed to pull ${service}, will use existing image or skip"
                fi
            done
            
            echo "🧹 Cleaning up unused images..."
            docker system prune -f || true
            
            # Start services in proper order with error handling
            echo "🚀 Starting infrastructure services..."
            if ! $DOCKER_COMPOSE up -d postgres redis rabbitmq; then
                echo "❌ Infrastructure startup failed, checking logs..."
                $DOCKER_COMPOSE logs postgres redis rabbitmq
                
                # Show detailed container status
                echo "Container status:"
                docker ps -a
                
                # Show specific error details
                echo "Detailed error information:"
                docker events --since 5m --until now | tail -10
                exit 1
            fi
            
            echo "⏳ Waiting for infrastructure (60s)..."
            sleep 60
            
            echo "📊 Infrastructure status:"
            $DOCKER_COMPOSE ps postgres redis rabbitmq
            
            # Test infrastructure connectivity
            echo "🔍 Testing infrastructure..."
            if docker exec finance-postgres pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} 2>/dev/null; then
                echo "  ✅ PostgreSQL is ready"
            else
                echo "  ⚠️ PostgreSQL not ready yet, continuing..."
            fi
            
            if docker exec finance-redis redis-cli ping 2>/dev/null | grep -q PONG; then
                echo "  ✅ Redis is ready"
            else
                echo "  ⚠️ Redis not ready yet, continuing..."
            fi
            
            echo "🚀 Starting application services..."
            if ! $DOCKER_COMPOSE up -d; then
                echo "❌ Application startup failed, showing diagnostic info..."
                
                # Show logs for failed services
                echo "=== Container Status ==="
                $DOCKER_COMPOSE ps
                
                echo "=== Recent Logs ==="
                $DOCKER_COMPOSE logs --tail=30
                
                echo "=== Failed Container Details ==="
                FAILED_CONTAINERS=$($DOCKER_COMPOSE ps -q --filter "status=exited" 2>/dev/null || echo "")
                if [ ! -z "$FAILED_CONTAINERS" ]; then
                    for container in $FAILED_CONTAINERS; do
                        container_name=$(docker inspect --format='{{.Name}}' $container 2>/dev/null || echo $container)
                        echo "--- Logs for $container_name ---"
                        docker logs --tail=20 $container 2>/dev/null || echo "No logs available"
                        echo ""
                    done
                fi
                
                exit 1
            fi
            
            echo "⏳ Waiting for all services (90s)..."
            sleep 90
            
            echo "📊 Final service status:"
            $DOCKER_COMPOSE ps
            
            # Test endpoints with proper error handling
            echo "🔍 Testing service endpoints..."
            
            # Test Gateway
            echo "  Testing Gateway API (http://localhost:8080/health)..."
            if timeout 60 bash -c 'while ! wget -q --spider http://localhost:8080/health 2>/dev/null; do echo "    Waiting for gateway..."; sleep 5; done'; then
                echo "    ✅ Gateway API is responding"
            else
                echo "    ⚠️ Gateway API not responding, checking logs:"
                $DOCKER_COMPOSE logs --tail=20 gateway 2>/dev/null || echo "    Gateway container not found"
            fi
            
            # Test Web Application  
            echo "  Testing Web Application (http://localhost:3000)..."
            if timeout 60 bash -c 'while ! wget -q --spider http://localhost:3000 2>/dev/null; do echo "    Waiting for web app..."; sleep 5; done'; then
                echo "    ✅ Web Application is responding"
            else
                echo "    ⚠️ Web Application not responding, checking logs:"
                $DOCKER_COMPOSE logs --tail=20 web 2>/dev/null || echo "    Web container not found"
            fi
            
            # Final status summary
            echo ""
            echo "🌐 Application URLs:"
            echo "  Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "  API Gateway: http://${{ secrets.EC2_HOST }}:8080" 
            echo "  Health Check: http://${{ secrets.EC2_HOST }}:8080/health"
            echo ""
            
            echo "📊 Final container status:"
            $DOCKER_COMPOSE ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" || $DOCKER_COMPOSE ps
            
            # Check for any issues
            FAILED_CONTAINERS=$($DOCKER_COMPOSE ps -q --filter "status=exited" 2>/dev/null || echo "")
            RUNNING_CONTAINERS=$($DOCKER_COMPOSE ps -q --filter "status=running" 2>/dev/null | wc -l)
            
            echo ""
            echo "📈 Deployment Summary:"
            echo "  Running containers: $RUNNING_CONTAINERS"
            
            if [ ! -z "$FAILED_CONTAINERS" ]; then
                echo "  ⚠️ Some containers failed - check logs above"
                echo "  Failed containers:"
                $DOCKER_COMPOSE ps --filter "status=exited"
            else
                echo "  ✅ All containers are running successfully"
            fi
            
            echo ""
            echo "🎉 ${{ steps.env.outputs.environment }} deployment completed!"

      # FIXED: Enhanced post-deployment verification
      - name: Post-deployment verification
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "🔍 Running post-deployment verification..."
            
            # Wait a bit more for services to stabilize
            sleep 30
            
            cd /home/ubuntu/finance-tracker
            
            # Determine Docker Compose command
            if command -v docker-compose &> /dev/null; then
                DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null; then
                DOCKER_COMPOSE="docker compose"
            else
                DOCKER_COMPOSE="docker compose"
            fi
            
            # Comprehensive health check
            HEALTH_STATUS="HEALTHY"
            
            echo "📊 Container Status:"
            $DOCKER_COMPOSE ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            echo ""
            
            # Check critical services
            echo "🏥 Health Check Results:"
            
            # Test Gateway
            echo "  Testing Gateway API..."
            if curl -f -m 10 http://localhost:8080/health 2>/dev/null; then
                echo "    ✅ Gateway API is healthy"
            else
                echo "    ❌ Gateway API is unhealthy"
                HEALTH_STATUS="UNHEALTHY"
            fi
            
            # Test Frontend
            echo "  Testing Web Application..."
            if curl -f -m 10 http://localhost:3000 2>/dev/null; then
                echo "    ✅ Web Application is healthy"
            else
                echo "    ❌ Web Application is unhealthy"
                HEALTH_STATUS="UNHEALTHY"
            fi
            
            # Test Database
            echo "  Testing Database..."
            if $DOCKER_COMPOSE exec -T postgres pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} 2>/dev/null; then
                echo "    ✅ Database is healthy"
            else
                echo "    ❌ Database is unhealthy"
                HEALTH_STATUS="UNHEALTHY"
            fi
            
            echo ""
            echo "🌐 Application URLs:"
            echo "  Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "  API Gateway: http://${{ secrets.EC2_HOST }}:8080"
            echo "  Health Check: http://${{ secrets.EC2_HOST }}:8080/health"
            echo ""
            
            if [ "$HEALTH_STATUS" = "HEALTHY" ]; then
                echo "✅ Post-deployment verification passed!"
            else
                echo "❌ Post-deployment verification failed!"
                echo ""
                echo "📋 Service Logs (last 10 lines each):"
                for service in gateway web postgres; do
                    echo "--- $service logs ---"
                    $DOCKER_COMPOSE logs --tail=10 $service || echo "Failed to get $service logs"
                    echo ""
                done
                exit 1
            fi

      - name: Deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "🎉 ${{ steps.env.outputs.environment }} deployment successful!"
            echo ""
            echo "🌐 Application Access:"
            echo "  Frontend: http://${{ secrets.EC2_HOST }}:3000"
            echo "  API Gateway: http://${{ secrets.EC2_HOST }}:8080"
            echo "  Health Check: http://${{ secrets.EC2_HOST }}:8080/health"
            echo ""
            echo "📊 Next Steps:"
            echo "  1. Access the application using the frontend URL"
            echo "  2. Register a new user account"
            echo "  3. Verify email functionality"
            echo "  4. Test expense tracking features"
          else
            echo "❌ ${{ steps.env.outputs.environment }} deployment failed!"
            echo ""
            echo "🔍 Troubleshooting:"
            echo "  1. Check the deployment logs above"
            echo "  2. SSH into EC2 and run: docker-compose logs"
            echo "  3. Verify Docker images exist on Docker Hub"
            echo "  4. Check EC2 instance resources (memory/disk)"
          fi